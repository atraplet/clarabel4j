// Generated by jextract

package com.ustermetrics.clarabel4j.bindings;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct ClarabelDefaultSettings_f64 {
 *     uint32_t max_iter;
 *     double time_limit;
 *     bool verbose;
 *     double max_step_fraction;
 *     double tol_gap_abs;
 *     double tol_gap_rel;
 *     double tol_feas;
 *     double tol_infeas_abs;
 *     double tol_infeas_rel;
 *     double tol_ktratio;
 *     double reduced_tol_gap_abs;
 *     double reduced_tol_gap_rel;
 *     double reduced_tol_feas;
 *     double reduced_tol_infeas_abs;
 *     double reduced_tol_infeas_rel;
 *     double reduced_tol_ktratio;
 *     bool equilibrate_enable;
 *     uint32_t equilibrate_max_iter;
 *     double equilibrate_min_scaling;
 *     double equilibrate_max_scaling;
 *     double linesearch_backtrack_step;
 *     double min_switch_step_length;
 *     double min_terminate_step_length;
 *     uint32_t max_threads;
 *     bool direct_kkt_solver;
 *     ClarabelDirectSolveMethods direct_solve_method;
 *     bool static_regularization_enable;
 *     double static_regularization_constant;
 *     double static_regularization_proportional;
 *     bool dynamic_regularization_enable;
 *     double dynamic_regularization_eps;
 *     double dynamic_regularization_delta;
 *     bool iterative_refinement_enable;
 *     double iterative_refinement_reltol;
 *     double iterative_refinement_abstol;
 *     uint32_t iterative_refinement_max_iter;
 *     double iterative_refinement_stop_ratio;
 *     bool presolve_enable;
 *     int32_t pardiso_iparm[64];
 *     bool pardiso_verbose;
 * }
 * }
 */
public class ClarabelDefaultSettings_f64 {

    ClarabelDefaultSettings_f64() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        Clarabel_h.C_INT.withName("max_iter"),
        MemoryLayout.paddingLayout(4),
        Clarabel_h.C_DOUBLE.withName("time_limit"),
        Clarabel_h.C_BOOL.withName("verbose"),
        MemoryLayout.paddingLayout(7),
        Clarabel_h.C_DOUBLE.withName("max_step_fraction"),
        Clarabel_h.C_DOUBLE.withName("tol_gap_abs"),
        Clarabel_h.C_DOUBLE.withName("tol_gap_rel"),
        Clarabel_h.C_DOUBLE.withName("tol_feas"),
        Clarabel_h.C_DOUBLE.withName("tol_infeas_abs"),
        Clarabel_h.C_DOUBLE.withName("tol_infeas_rel"),
        Clarabel_h.C_DOUBLE.withName("tol_ktratio"),
        Clarabel_h.C_DOUBLE.withName("reduced_tol_gap_abs"),
        Clarabel_h.C_DOUBLE.withName("reduced_tol_gap_rel"),
        Clarabel_h.C_DOUBLE.withName("reduced_tol_feas"),
        Clarabel_h.C_DOUBLE.withName("reduced_tol_infeas_abs"),
        Clarabel_h.C_DOUBLE.withName("reduced_tol_infeas_rel"),
        Clarabel_h.C_DOUBLE.withName("reduced_tol_ktratio"),
        Clarabel_h.C_BOOL.withName("equilibrate_enable"),
        MemoryLayout.paddingLayout(3),
        Clarabel_h.C_INT.withName("equilibrate_max_iter"),
        Clarabel_h.C_DOUBLE.withName("equilibrate_min_scaling"),
        Clarabel_h.C_DOUBLE.withName("equilibrate_max_scaling"),
        Clarabel_h.C_DOUBLE.withName("linesearch_backtrack_step"),
        Clarabel_h.C_DOUBLE.withName("min_switch_step_length"),
        Clarabel_h.C_DOUBLE.withName("min_terminate_step_length"),
        Clarabel_h.C_INT.withName("max_threads"),
        Clarabel_h.C_BOOL.withName("direct_kkt_solver"),
        MemoryLayout.paddingLayout(3),
        Clarabel_h.C_INT.withName("direct_solve_method"),
        Clarabel_h.C_BOOL.withName("static_regularization_enable"),
        MemoryLayout.paddingLayout(3),
        Clarabel_h.C_DOUBLE.withName("static_regularization_constant"),
        Clarabel_h.C_DOUBLE.withName("static_regularization_proportional"),
        Clarabel_h.C_BOOL.withName("dynamic_regularization_enable"),
        MemoryLayout.paddingLayout(7),
        Clarabel_h.C_DOUBLE.withName("dynamic_regularization_eps"),
        Clarabel_h.C_DOUBLE.withName("dynamic_regularization_delta"),
        Clarabel_h.C_BOOL.withName("iterative_refinement_enable"),
        MemoryLayout.paddingLayout(7),
        Clarabel_h.C_DOUBLE.withName("iterative_refinement_reltol"),
        Clarabel_h.C_DOUBLE.withName("iterative_refinement_abstol"),
        Clarabel_h.C_INT.withName("iterative_refinement_max_iter"),
        MemoryLayout.paddingLayout(4),
        Clarabel_h.C_DOUBLE.withName("iterative_refinement_stop_ratio"),
        Clarabel_h.C_BOOL.withName("presolve_enable"),
        MemoryLayout.paddingLayout(3),
        MemoryLayout.sequenceLayout(64, Clarabel_h.C_INT).withName("pardiso_iparm"),
        Clarabel_h.C_BOOL.withName("pardiso_verbose"),
        MemoryLayout.paddingLayout(3)
    ).withName("ClarabelDefaultSettings_f64");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt max_iter$LAYOUT = (OfInt)$LAYOUT.select(groupElement("max_iter"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t max_iter
     * }
     */
    public static final OfInt max_iter$layout() {
        return max_iter$LAYOUT;
    }

    private static final long max_iter$OFFSET = $LAYOUT.byteOffset(groupElement("max_iter"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t max_iter
     * }
     */
    public static final long max_iter$offset() {
        return max_iter$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t max_iter
     * }
     */
    public static int max_iter(MemorySegment struct) {
        return struct.get(max_iter$LAYOUT, max_iter$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t max_iter
     * }
     */
    public static void max_iter(MemorySegment struct, int fieldValue) {
        struct.set(max_iter$LAYOUT, max_iter$OFFSET, fieldValue);
    }

    private static final OfDouble time_limit$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("time_limit"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double time_limit
     * }
     */
    public static final OfDouble time_limit$layout() {
        return time_limit$LAYOUT;
    }

    private static final long time_limit$OFFSET = $LAYOUT.byteOffset(groupElement("time_limit"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double time_limit
     * }
     */
    public static final long time_limit$offset() {
        return time_limit$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double time_limit
     * }
     */
    public static double time_limit(MemorySegment struct) {
        return struct.get(time_limit$LAYOUT, time_limit$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double time_limit
     * }
     */
    public static void time_limit(MemorySegment struct, double fieldValue) {
        struct.set(time_limit$LAYOUT, time_limit$OFFSET, fieldValue);
    }

    private static final OfBoolean verbose$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("verbose"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool verbose
     * }
     */
    public static final OfBoolean verbose$layout() {
        return verbose$LAYOUT;
    }

    private static final long verbose$OFFSET = $LAYOUT.byteOffset(groupElement("verbose"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool verbose
     * }
     */
    public static final long verbose$offset() {
        return verbose$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool verbose
     * }
     */
    public static boolean verbose(MemorySegment struct) {
        return struct.get(verbose$LAYOUT, verbose$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool verbose
     * }
     */
    public static void verbose(MemorySegment struct, boolean fieldValue) {
        struct.set(verbose$LAYOUT, verbose$OFFSET, fieldValue);
    }

    private static final OfDouble max_step_fraction$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("max_step_fraction"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double max_step_fraction
     * }
     */
    public static final OfDouble max_step_fraction$layout() {
        return max_step_fraction$LAYOUT;
    }

    private static final long max_step_fraction$OFFSET = $LAYOUT.byteOffset(groupElement("max_step_fraction"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double max_step_fraction
     * }
     */
    public static final long max_step_fraction$offset() {
        return max_step_fraction$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double max_step_fraction
     * }
     */
    public static double max_step_fraction(MemorySegment struct) {
        return struct.get(max_step_fraction$LAYOUT, max_step_fraction$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double max_step_fraction
     * }
     */
    public static void max_step_fraction(MemorySegment struct, double fieldValue) {
        struct.set(max_step_fraction$LAYOUT, max_step_fraction$OFFSET, fieldValue);
    }

    private static final OfDouble tol_gap_abs$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("tol_gap_abs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double tol_gap_abs
     * }
     */
    public static final OfDouble tol_gap_abs$layout() {
        return tol_gap_abs$LAYOUT;
    }

    private static final long tol_gap_abs$OFFSET = $LAYOUT.byteOffset(groupElement("tol_gap_abs"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double tol_gap_abs
     * }
     */
    public static final long tol_gap_abs$offset() {
        return tol_gap_abs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double tol_gap_abs
     * }
     */
    public static double tol_gap_abs(MemorySegment struct) {
        return struct.get(tol_gap_abs$LAYOUT, tol_gap_abs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double tol_gap_abs
     * }
     */
    public static void tol_gap_abs(MemorySegment struct, double fieldValue) {
        struct.set(tol_gap_abs$LAYOUT, tol_gap_abs$OFFSET, fieldValue);
    }

    private static final OfDouble tol_gap_rel$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("tol_gap_rel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double tol_gap_rel
     * }
     */
    public static final OfDouble tol_gap_rel$layout() {
        return tol_gap_rel$LAYOUT;
    }

    private static final long tol_gap_rel$OFFSET = $LAYOUT.byteOffset(groupElement("tol_gap_rel"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double tol_gap_rel
     * }
     */
    public static final long tol_gap_rel$offset() {
        return tol_gap_rel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double tol_gap_rel
     * }
     */
    public static double tol_gap_rel(MemorySegment struct) {
        return struct.get(tol_gap_rel$LAYOUT, tol_gap_rel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double tol_gap_rel
     * }
     */
    public static void tol_gap_rel(MemorySegment struct, double fieldValue) {
        struct.set(tol_gap_rel$LAYOUT, tol_gap_rel$OFFSET, fieldValue);
    }

    private static final OfDouble tol_feas$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("tol_feas"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double tol_feas
     * }
     */
    public static final OfDouble tol_feas$layout() {
        return tol_feas$LAYOUT;
    }

    private static final long tol_feas$OFFSET = $LAYOUT.byteOffset(groupElement("tol_feas"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double tol_feas
     * }
     */
    public static final long tol_feas$offset() {
        return tol_feas$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double tol_feas
     * }
     */
    public static double tol_feas(MemorySegment struct) {
        return struct.get(tol_feas$LAYOUT, tol_feas$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double tol_feas
     * }
     */
    public static void tol_feas(MemorySegment struct, double fieldValue) {
        struct.set(tol_feas$LAYOUT, tol_feas$OFFSET, fieldValue);
    }

    private static final OfDouble tol_infeas_abs$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("tol_infeas_abs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double tol_infeas_abs
     * }
     */
    public static final OfDouble tol_infeas_abs$layout() {
        return tol_infeas_abs$LAYOUT;
    }

    private static final long tol_infeas_abs$OFFSET = $LAYOUT.byteOffset(groupElement("tol_infeas_abs"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double tol_infeas_abs
     * }
     */
    public static final long tol_infeas_abs$offset() {
        return tol_infeas_abs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double tol_infeas_abs
     * }
     */
    public static double tol_infeas_abs(MemorySegment struct) {
        return struct.get(tol_infeas_abs$LAYOUT, tol_infeas_abs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double tol_infeas_abs
     * }
     */
    public static void tol_infeas_abs(MemorySegment struct, double fieldValue) {
        struct.set(tol_infeas_abs$LAYOUT, tol_infeas_abs$OFFSET, fieldValue);
    }

    private static final OfDouble tol_infeas_rel$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("tol_infeas_rel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double tol_infeas_rel
     * }
     */
    public static final OfDouble tol_infeas_rel$layout() {
        return tol_infeas_rel$LAYOUT;
    }

    private static final long tol_infeas_rel$OFFSET = $LAYOUT.byteOffset(groupElement("tol_infeas_rel"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double tol_infeas_rel
     * }
     */
    public static final long tol_infeas_rel$offset() {
        return tol_infeas_rel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double tol_infeas_rel
     * }
     */
    public static double tol_infeas_rel(MemorySegment struct) {
        return struct.get(tol_infeas_rel$LAYOUT, tol_infeas_rel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double tol_infeas_rel
     * }
     */
    public static void tol_infeas_rel(MemorySegment struct, double fieldValue) {
        struct.set(tol_infeas_rel$LAYOUT, tol_infeas_rel$OFFSET, fieldValue);
    }

    private static final OfDouble tol_ktratio$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("tol_ktratio"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double tol_ktratio
     * }
     */
    public static final OfDouble tol_ktratio$layout() {
        return tol_ktratio$LAYOUT;
    }

    private static final long tol_ktratio$OFFSET = $LAYOUT.byteOffset(groupElement("tol_ktratio"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double tol_ktratio
     * }
     */
    public static final long tol_ktratio$offset() {
        return tol_ktratio$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double tol_ktratio
     * }
     */
    public static double tol_ktratio(MemorySegment struct) {
        return struct.get(tol_ktratio$LAYOUT, tol_ktratio$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double tol_ktratio
     * }
     */
    public static void tol_ktratio(MemorySegment struct, double fieldValue) {
        struct.set(tol_ktratio$LAYOUT, tol_ktratio$OFFSET, fieldValue);
    }

    private static final OfDouble reduced_tol_gap_abs$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("reduced_tol_gap_abs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double reduced_tol_gap_abs
     * }
     */
    public static final OfDouble reduced_tol_gap_abs$layout() {
        return reduced_tol_gap_abs$LAYOUT;
    }

    private static final long reduced_tol_gap_abs$OFFSET = $LAYOUT.byteOffset(groupElement("reduced_tol_gap_abs"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double reduced_tol_gap_abs
     * }
     */
    public static final long reduced_tol_gap_abs$offset() {
        return reduced_tol_gap_abs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double reduced_tol_gap_abs
     * }
     */
    public static double reduced_tol_gap_abs(MemorySegment struct) {
        return struct.get(reduced_tol_gap_abs$LAYOUT, reduced_tol_gap_abs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double reduced_tol_gap_abs
     * }
     */
    public static void reduced_tol_gap_abs(MemorySegment struct, double fieldValue) {
        struct.set(reduced_tol_gap_abs$LAYOUT, reduced_tol_gap_abs$OFFSET, fieldValue);
    }

    private static final OfDouble reduced_tol_gap_rel$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("reduced_tol_gap_rel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double reduced_tol_gap_rel
     * }
     */
    public static final OfDouble reduced_tol_gap_rel$layout() {
        return reduced_tol_gap_rel$LAYOUT;
    }

    private static final long reduced_tol_gap_rel$OFFSET = $LAYOUT.byteOffset(groupElement("reduced_tol_gap_rel"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double reduced_tol_gap_rel
     * }
     */
    public static final long reduced_tol_gap_rel$offset() {
        return reduced_tol_gap_rel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double reduced_tol_gap_rel
     * }
     */
    public static double reduced_tol_gap_rel(MemorySegment struct) {
        return struct.get(reduced_tol_gap_rel$LAYOUT, reduced_tol_gap_rel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double reduced_tol_gap_rel
     * }
     */
    public static void reduced_tol_gap_rel(MemorySegment struct, double fieldValue) {
        struct.set(reduced_tol_gap_rel$LAYOUT, reduced_tol_gap_rel$OFFSET, fieldValue);
    }

    private static final OfDouble reduced_tol_feas$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("reduced_tol_feas"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double reduced_tol_feas
     * }
     */
    public static final OfDouble reduced_tol_feas$layout() {
        return reduced_tol_feas$LAYOUT;
    }

    private static final long reduced_tol_feas$OFFSET = $LAYOUT.byteOffset(groupElement("reduced_tol_feas"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double reduced_tol_feas
     * }
     */
    public static final long reduced_tol_feas$offset() {
        return reduced_tol_feas$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double reduced_tol_feas
     * }
     */
    public static double reduced_tol_feas(MemorySegment struct) {
        return struct.get(reduced_tol_feas$LAYOUT, reduced_tol_feas$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double reduced_tol_feas
     * }
     */
    public static void reduced_tol_feas(MemorySegment struct, double fieldValue) {
        struct.set(reduced_tol_feas$LAYOUT, reduced_tol_feas$OFFSET, fieldValue);
    }

    private static final OfDouble reduced_tol_infeas_abs$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("reduced_tol_infeas_abs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double reduced_tol_infeas_abs
     * }
     */
    public static final OfDouble reduced_tol_infeas_abs$layout() {
        return reduced_tol_infeas_abs$LAYOUT;
    }

    private static final long reduced_tol_infeas_abs$OFFSET = $LAYOUT.byteOffset(groupElement("reduced_tol_infeas_abs"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double reduced_tol_infeas_abs
     * }
     */
    public static final long reduced_tol_infeas_abs$offset() {
        return reduced_tol_infeas_abs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double reduced_tol_infeas_abs
     * }
     */
    public static double reduced_tol_infeas_abs(MemorySegment struct) {
        return struct.get(reduced_tol_infeas_abs$LAYOUT, reduced_tol_infeas_abs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double reduced_tol_infeas_abs
     * }
     */
    public static void reduced_tol_infeas_abs(MemorySegment struct, double fieldValue) {
        struct.set(reduced_tol_infeas_abs$LAYOUT, reduced_tol_infeas_abs$OFFSET, fieldValue);
    }

    private static final OfDouble reduced_tol_infeas_rel$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("reduced_tol_infeas_rel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double reduced_tol_infeas_rel
     * }
     */
    public static final OfDouble reduced_tol_infeas_rel$layout() {
        return reduced_tol_infeas_rel$LAYOUT;
    }

    private static final long reduced_tol_infeas_rel$OFFSET = $LAYOUT.byteOffset(groupElement("reduced_tol_infeas_rel"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double reduced_tol_infeas_rel
     * }
     */
    public static final long reduced_tol_infeas_rel$offset() {
        return reduced_tol_infeas_rel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double reduced_tol_infeas_rel
     * }
     */
    public static double reduced_tol_infeas_rel(MemorySegment struct) {
        return struct.get(reduced_tol_infeas_rel$LAYOUT, reduced_tol_infeas_rel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double reduced_tol_infeas_rel
     * }
     */
    public static void reduced_tol_infeas_rel(MemorySegment struct, double fieldValue) {
        struct.set(reduced_tol_infeas_rel$LAYOUT, reduced_tol_infeas_rel$OFFSET, fieldValue);
    }

    private static final OfDouble reduced_tol_ktratio$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("reduced_tol_ktratio"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double reduced_tol_ktratio
     * }
     */
    public static final OfDouble reduced_tol_ktratio$layout() {
        return reduced_tol_ktratio$LAYOUT;
    }

    private static final long reduced_tol_ktratio$OFFSET = $LAYOUT.byteOffset(groupElement("reduced_tol_ktratio"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double reduced_tol_ktratio
     * }
     */
    public static final long reduced_tol_ktratio$offset() {
        return reduced_tol_ktratio$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double reduced_tol_ktratio
     * }
     */
    public static double reduced_tol_ktratio(MemorySegment struct) {
        return struct.get(reduced_tol_ktratio$LAYOUT, reduced_tol_ktratio$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double reduced_tol_ktratio
     * }
     */
    public static void reduced_tol_ktratio(MemorySegment struct, double fieldValue) {
        struct.set(reduced_tol_ktratio$LAYOUT, reduced_tol_ktratio$OFFSET, fieldValue);
    }

    private static final OfBoolean equilibrate_enable$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("equilibrate_enable"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool equilibrate_enable
     * }
     */
    public static final OfBoolean equilibrate_enable$layout() {
        return equilibrate_enable$LAYOUT;
    }

    private static final long equilibrate_enable$OFFSET = $LAYOUT.byteOffset(groupElement("equilibrate_enable"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool equilibrate_enable
     * }
     */
    public static final long equilibrate_enable$offset() {
        return equilibrate_enable$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool equilibrate_enable
     * }
     */
    public static boolean equilibrate_enable(MemorySegment struct) {
        return struct.get(equilibrate_enable$LAYOUT, equilibrate_enable$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool equilibrate_enable
     * }
     */
    public static void equilibrate_enable(MemorySegment struct, boolean fieldValue) {
        struct.set(equilibrate_enable$LAYOUT, equilibrate_enable$OFFSET, fieldValue);
    }

    private static final OfInt equilibrate_max_iter$LAYOUT = (OfInt)$LAYOUT.select(groupElement("equilibrate_max_iter"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t equilibrate_max_iter
     * }
     */
    public static final OfInt equilibrate_max_iter$layout() {
        return equilibrate_max_iter$LAYOUT;
    }

    private static final long equilibrate_max_iter$OFFSET = $LAYOUT.byteOffset(groupElement("equilibrate_max_iter"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t equilibrate_max_iter
     * }
     */
    public static final long equilibrate_max_iter$offset() {
        return equilibrate_max_iter$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t equilibrate_max_iter
     * }
     */
    public static int equilibrate_max_iter(MemorySegment struct) {
        return struct.get(equilibrate_max_iter$LAYOUT, equilibrate_max_iter$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t equilibrate_max_iter
     * }
     */
    public static void equilibrate_max_iter(MemorySegment struct, int fieldValue) {
        struct.set(equilibrate_max_iter$LAYOUT, equilibrate_max_iter$OFFSET, fieldValue);
    }

    private static final OfDouble equilibrate_min_scaling$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("equilibrate_min_scaling"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double equilibrate_min_scaling
     * }
     */
    public static final OfDouble equilibrate_min_scaling$layout() {
        return equilibrate_min_scaling$LAYOUT;
    }

    private static final long equilibrate_min_scaling$OFFSET = $LAYOUT.byteOffset(groupElement("equilibrate_min_scaling"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double equilibrate_min_scaling
     * }
     */
    public static final long equilibrate_min_scaling$offset() {
        return equilibrate_min_scaling$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double equilibrate_min_scaling
     * }
     */
    public static double equilibrate_min_scaling(MemorySegment struct) {
        return struct.get(equilibrate_min_scaling$LAYOUT, equilibrate_min_scaling$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double equilibrate_min_scaling
     * }
     */
    public static void equilibrate_min_scaling(MemorySegment struct, double fieldValue) {
        struct.set(equilibrate_min_scaling$LAYOUT, equilibrate_min_scaling$OFFSET, fieldValue);
    }

    private static final OfDouble equilibrate_max_scaling$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("equilibrate_max_scaling"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double equilibrate_max_scaling
     * }
     */
    public static final OfDouble equilibrate_max_scaling$layout() {
        return equilibrate_max_scaling$LAYOUT;
    }

    private static final long equilibrate_max_scaling$OFFSET = $LAYOUT.byteOffset(groupElement("equilibrate_max_scaling"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double equilibrate_max_scaling
     * }
     */
    public static final long equilibrate_max_scaling$offset() {
        return equilibrate_max_scaling$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double equilibrate_max_scaling
     * }
     */
    public static double equilibrate_max_scaling(MemorySegment struct) {
        return struct.get(equilibrate_max_scaling$LAYOUT, equilibrate_max_scaling$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double equilibrate_max_scaling
     * }
     */
    public static void equilibrate_max_scaling(MemorySegment struct, double fieldValue) {
        struct.set(equilibrate_max_scaling$LAYOUT, equilibrate_max_scaling$OFFSET, fieldValue);
    }

    private static final OfDouble linesearch_backtrack_step$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("linesearch_backtrack_step"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double linesearch_backtrack_step
     * }
     */
    public static final OfDouble linesearch_backtrack_step$layout() {
        return linesearch_backtrack_step$LAYOUT;
    }

    private static final long linesearch_backtrack_step$OFFSET = $LAYOUT.byteOffset(groupElement("linesearch_backtrack_step"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double linesearch_backtrack_step
     * }
     */
    public static final long linesearch_backtrack_step$offset() {
        return linesearch_backtrack_step$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double linesearch_backtrack_step
     * }
     */
    public static double linesearch_backtrack_step(MemorySegment struct) {
        return struct.get(linesearch_backtrack_step$LAYOUT, linesearch_backtrack_step$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double linesearch_backtrack_step
     * }
     */
    public static void linesearch_backtrack_step(MemorySegment struct, double fieldValue) {
        struct.set(linesearch_backtrack_step$LAYOUT, linesearch_backtrack_step$OFFSET, fieldValue);
    }

    private static final OfDouble min_switch_step_length$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("min_switch_step_length"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double min_switch_step_length
     * }
     */
    public static final OfDouble min_switch_step_length$layout() {
        return min_switch_step_length$LAYOUT;
    }

    private static final long min_switch_step_length$OFFSET = $LAYOUT.byteOffset(groupElement("min_switch_step_length"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double min_switch_step_length
     * }
     */
    public static final long min_switch_step_length$offset() {
        return min_switch_step_length$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double min_switch_step_length
     * }
     */
    public static double min_switch_step_length(MemorySegment struct) {
        return struct.get(min_switch_step_length$LAYOUT, min_switch_step_length$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double min_switch_step_length
     * }
     */
    public static void min_switch_step_length(MemorySegment struct, double fieldValue) {
        struct.set(min_switch_step_length$LAYOUT, min_switch_step_length$OFFSET, fieldValue);
    }

    private static final OfDouble min_terminate_step_length$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("min_terminate_step_length"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double min_terminate_step_length
     * }
     */
    public static final OfDouble min_terminate_step_length$layout() {
        return min_terminate_step_length$LAYOUT;
    }

    private static final long min_terminate_step_length$OFFSET = $LAYOUT.byteOffset(groupElement("min_terminate_step_length"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double min_terminate_step_length
     * }
     */
    public static final long min_terminate_step_length$offset() {
        return min_terminate_step_length$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double min_terminate_step_length
     * }
     */
    public static double min_terminate_step_length(MemorySegment struct) {
        return struct.get(min_terminate_step_length$LAYOUT, min_terminate_step_length$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double min_terminate_step_length
     * }
     */
    public static void min_terminate_step_length(MemorySegment struct, double fieldValue) {
        struct.set(min_terminate_step_length$LAYOUT, min_terminate_step_length$OFFSET, fieldValue);
    }

    private static final OfInt max_threads$LAYOUT = (OfInt)$LAYOUT.select(groupElement("max_threads"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t max_threads
     * }
     */
    public static final OfInt max_threads$layout() {
        return max_threads$LAYOUT;
    }

    private static final long max_threads$OFFSET = $LAYOUT.byteOffset(groupElement("max_threads"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t max_threads
     * }
     */
    public static final long max_threads$offset() {
        return max_threads$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t max_threads
     * }
     */
    public static int max_threads(MemorySegment struct) {
        return struct.get(max_threads$LAYOUT, max_threads$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t max_threads
     * }
     */
    public static void max_threads(MemorySegment struct, int fieldValue) {
        struct.set(max_threads$LAYOUT, max_threads$OFFSET, fieldValue);
    }

    private static final OfBoolean direct_kkt_solver$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("direct_kkt_solver"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool direct_kkt_solver
     * }
     */
    public static final OfBoolean direct_kkt_solver$layout() {
        return direct_kkt_solver$LAYOUT;
    }

    private static final long direct_kkt_solver$OFFSET = $LAYOUT.byteOffset(groupElement("direct_kkt_solver"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool direct_kkt_solver
     * }
     */
    public static final long direct_kkt_solver$offset() {
        return direct_kkt_solver$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool direct_kkt_solver
     * }
     */
    public static boolean direct_kkt_solver(MemorySegment struct) {
        return struct.get(direct_kkt_solver$LAYOUT, direct_kkt_solver$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool direct_kkt_solver
     * }
     */
    public static void direct_kkt_solver(MemorySegment struct, boolean fieldValue) {
        struct.set(direct_kkt_solver$LAYOUT, direct_kkt_solver$OFFSET, fieldValue);
    }

    private static final OfInt direct_solve_method$LAYOUT = (OfInt)$LAYOUT.select(groupElement("direct_solve_method"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ClarabelDirectSolveMethods direct_solve_method
     * }
     */
    public static final OfInt direct_solve_method$layout() {
        return direct_solve_method$LAYOUT;
    }

    private static final long direct_solve_method$OFFSET = $LAYOUT.byteOffset(groupElement("direct_solve_method"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ClarabelDirectSolveMethods direct_solve_method
     * }
     */
    public static final long direct_solve_method$offset() {
        return direct_solve_method$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ClarabelDirectSolveMethods direct_solve_method
     * }
     */
    public static int direct_solve_method(MemorySegment struct) {
        return struct.get(direct_solve_method$LAYOUT, direct_solve_method$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ClarabelDirectSolveMethods direct_solve_method
     * }
     */
    public static void direct_solve_method(MemorySegment struct, int fieldValue) {
        struct.set(direct_solve_method$LAYOUT, direct_solve_method$OFFSET, fieldValue);
    }

    private static final OfBoolean static_regularization_enable$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("static_regularization_enable"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool static_regularization_enable
     * }
     */
    public static final OfBoolean static_regularization_enable$layout() {
        return static_regularization_enable$LAYOUT;
    }

    private static final long static_regularization_enable$OFFSET = $LAYOUT.byteOffset(groupElement("static_regularization_enable"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool static_regularization_enable
     * }
     */
    public static final long static_regularization_enable$offset() {
        return static_regularization_enable$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool static_regularization_enable
     * }
     */
    public static boolean static_regularization_enable(MemorySegment struct) {
        return struct.get(static_regularization_enable$LAYOUT, static_regularization_enable$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool static_regularization_enable
     * }
     */
    public static void static_regularization_enable(MemorySegment struct, boolean fieldValue) {
        struct.set(static_regularization_enable$LAYOUT, static_regularization_enable$OFFSET, fieldValue);
    }

    private static final OfDouble static_regularization_constant$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("static_regularization_constant"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double static_regularization_constant
     * }
     */
    public static final OfDouble static_regularization_constant$layout() {
        return static_regularization_constant$LAYOUT;
    }

    private static final long static_regularization_constant$OFFSET = $LAYOUT.byteOffset(groupElement("static_regularization_constant"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double static_regularization_constant
     * }
     */
    public static final long static_regularization_constant$offset() {
        return static_regularization_constant$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double static_regularization_constant
     * }
     */
    public static double static_regularization_constant(MemorySegment struct) {
        return struct.get(static_regularization_constant$LAYOUT, static_regularization_constant$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double static_regularization_constant
     * }
     */
    public static void static_regularization_constant(MemorySegment struct, double fieldValue) {
        struct.set(static_regularization_constant$LAYOUT, static_regularization_constant$OFFSET, fieldValue);
    }

    private static final OfDouble static_regularization_proportional$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("static_regularization_proportional"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double static_regularization_proportional
     * }
     */
    public static final OfDouble static_regularization_proportional$layout() {
        return static_regularization_proportional$LAYOUT;
    }

    private static final long static_regularization_proportional$OFFSET = $LAYOUT.byteOffset(groupElement("static_regularization_proportional"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double static_regularization_proportional
     * }
     */
    public static final long static_regularization_proportional$offset() {
        return static_regularization_proportional$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double static_regularization_proportional
     * }
     */
    public static double static_regularization_proportional(MemorySegment struct) {
        return struct.get(static_regularization_proportional$LAYOUT, static_regularization_proportional$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double static_regularization_proportional
     * }
     */
    public static void static_regularization_proportional(MemorySegment struct, double fieldValue) {
        struct.set(static_regularization_proportional$LAYOUT, static_regularization_proportional$OFFSET, fieldValue);
    }

    private static final OfBoolean dynamic_regularization_enable$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("dynamic_regularization_enable"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool dynamic_regularization_enable
     * }
     */
    public static final OfBoolean dynamic_regularization_enable$layout() {
        return dynamic_regularization_enable$LAYOUT;
    }

    private static final long dynamic_regularization_enable$OFFSET = $LAYOUT.byteOffset(groupElement("dynamic_regularization_enable"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool dynamic_regularization_enable
     * }
     */
    public static final long dynamic_regularization_enable$offset() {
        return dynamic_regularization_enable$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool dynamic_regularization_enable
     * }
     */
    public static boolean dynamic_regularization_enable(MemorySegment struct) {
        return struct.get(dynamic_regularization_enable$LAYOUT, dynamic_regularization_enable$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool dynamic_regularization_enable
     * }
     */
    public static void dynamic_regularization_enable(MemorySegment struct, boolean fieldValue) {
        struct.set(dynamic_regularization_enable$LAYOUT, dynamic_regularization_enable$OFFSET, fieldValue);
    }

    private static final OfDouble dynamic_regularization_eps$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("dynamic_regularization_eps"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double dynamic_regularization_eps
     * }
     */
    public static final OfDouble dynamic_regularization_eps$layout() {
        return dynamic_regularization_eps$LAYOUT;
    }

    private static final long dynamic_regularization_eps$OFFSET = $LAYOUT.byteOffset(groupElement("dynamic_regularization_eps"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double dynamic_regularization_eps
     * }
     */
    public static final long dynamic_regularization_eps$offset() {
        return dynamic_regularization_eps$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double dynamic_regularization_eps
     * }
     */
    public static double dynamic_regularization_eps(MemorySegment struct) {
        return struct.get(dynamic_regularization_eps$LAYOUT, dynamic_regularization_eps$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double dynamic_regularization_eps
     * }
     */
    public static void dynamic_regularization_eps(MemorySegment struct, double fieldValue) {
        struct.set(dynamic_regularization_eps$LAYOUT, dynamic_regularization_eps$OFFSET, fieldValue);
    }

    private static final OfDouble dynamic_regularization_delta$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("dynamic_regularization_delta"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double dynamic_regularization_delta
     * }
     */
    public static final OfDouble dynamic_regularization_delta$layout() {
        return dynamic_regularization_delta$LAYOUT;
    }

    private static final long dynamic_regularization_delta$OFFSET = $LAYOUT.byteOffset(groupElement("dynamic_regularization_delta"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double dynamic_regularization_delta
     * }
     */
    public static final long dynamic_regularization_delta$offset() {
        return dynamic_regularization_delta$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double dynamic_regularization_delta
     * }
     */
    public static double dynamic_regularization_delta(MemorySegment struct) {
        return struct.get(dynamic_regularization_delta$LAYOUT, dynamic_regularization_delta$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double dynamic_regularization_delta
     * }
     */
    public static void dynamic_regularization_delta(MemorySegment struct, double fieldValue) {
        struct.set(dynamic_regularization_delta$LAYOUT, dynamic_regularization_delta$OFFSET, fieldValue);
    }

    private static final OfBoolean iterative_refinement_enable$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("iterative_refinement_enable"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool iterative_refinement_enable
     * }
     */
    public static final OfBoolean iterative_refinement_enable$layout() {
        return iterative_refinement_enable$LAYOUT;
    }

    private static final long iterative_refinement_enable$OFFSET = $LAYOUT.byteOffset(groupElement("iterative_refinement_enable"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool iterative_refinement_enable
     * }
     */
    public static final long iterative_refinement_enable$offset() {
        return iterative_refinement_enable$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool iterative_refinement_enable
     * }
     */
    public static boolean iterative_refinement_enable(MemorySegment struct) {
        return struct.get(iterative_refinement_enable$LAYOUT, iterative_refinement_enable$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool iterative_refinement_enable
     * }
     */
    public static void iterative_refinement_enable(MemorySegment struct, boolean fieldValue) {
        struct.set(iterative_refinement_enable$LAYOUT, iterative_refinement_enable$OFFSET, fieldValue);
    }

    private static final OfDouble iterative_refinement_reltol$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("iterative_refinement_reltol"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double iterative_refinement_reltol
     * }
     */
    public static final OfDouble iterative_refinement_reltol$layout() {
        return iterative_refinement_reltol$LAYOUT;
    }

    private static final long iterative_refinement_reltol$OFFSET = $LAYOUT.byteOffset(groupElement("iterative_refinement_reltol"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double iterative_refinement_reltol
     * }
     */
    public static final long iterative_refinement_reltol$offset() {
        return iterative_refinement_reltol$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double iterative_refinement_reltol
     * }
     */
    public static double iterative_refinement_reltol(MemorySegment struct) {
        return struct.get(iterative_refinement_reltol$LAYOUT, iterative_refinement_reltol$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double iterative_refinement_reltol
     * }
     */
    public static void iterative_refinement_reltol(MemorySegment struct, double fieldValue) {
        struct.set(iterative_refinement_reltol$LAYOUT, iterative_refinement_reltol$OFFSET, fieldValue);
    }

    private static final OfDouble iterative_refinement_abstol$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("iterative_refinement_abstol"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double iterative_refinement_abstol
     * }
     */
    public static final OfDouble iterative_refinement_abstol$layout() {
        return iterative_refinement_abstol$LAYOUT;
    }

    private static final long iterative_refinement_abstol$OFFSET = $LAYOUT.byteOffset(groupElement("iterative_refinement_abstol"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double iterative_refinement_abstol
     * }
     */
    public static final long iterative_refinement_abstol$offset() {
        return iterative_refinement_abstol$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double iterative_refinement_abstol
     * }
     */
    public static double iterative_refinement_abstol(MemorySegment struct) {
        return struct.get(iterative_refinement_abstol$LAYOUT, iterative_refinement_abstol$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double iterative_refinement_abstol
     * }
     */
    public static void iterative_refinement_abstol(MemorySegment struct, double fieldValue) {
        struct.set(iterative_refinement_abstol$LAYOUT, iterative_refinement_abstol$OFFSET, fieldValue);
    }

    private static final OfInt iterative_refinement_max_iter$LAYOUT = (OfInt)$LAYOUT.select(groupElement("iterative_refinement_max_iter"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t iterative_refinement_max_iter
     * }
     */
    public static final OfInt iterative_refinement_max_iter$layout() {
        return iterative_refinement_max_iter$LAYOUT;
    }

    private static final long iterative_refinement_max_iter$OFFSET = $LAYOUT.byteOffset(groupElement("iterative_refinement_max_iter"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t iterative_refinement_max_iter
     * }
     */
    public static final long iterative_refinement_max_iter$offset() {
        return iterative_refinement_max_iter$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t iterative_refinement_max_iter
     * }
     */
    public static int iterative_refinement_max_iter(MemorySegment struct) {
        return struct.get(iterative_refinement_max_iter$LAYOUT, iterative_refinement_max_iter$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t iterative_refinement_max_iter
     * }
     */
    public static void iterative_refinement_max_iter(MemorySegment struct, int fieldValue) {
        struct.set(iterative_refinement_max_iter$LAYOUT, iterative_refinement_max_iter$OFFSET, fieldValue);
    }

    private static final OfDouble iterative_refinement_stop_ratio$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("iterative_refinement_stop_ratio"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double iterative_refinement_stop_ratio
     * }
     */
    public static final OfDouble iterative_refinement_stop_ratio$layout() {
        return iterative_refinement_stop_ratio$LAYOUT;
    }

    private static final long iterative_refinement_stop_ratio$OFFSET = $LAYOUT.byteOffset(groupElement("iterative_refinement_stop_ratio"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double iterative_refinement_stop_ratio
     * }
     */
    public static final long iterative_refinement_stop_ratio$offset() {
        return iterative_refinement_stop_ratio$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double iterative_refinement_stop_ratio
     * }
     */
    public static double iterative_refinement_stop_ratio(MemorySegment struct) {
        return struct.get(iterative_refinement_stop_ratio$LAYOUT, iterative_refinement_stop_ratio$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double iterative_refinement_stop_ratio
     * }
     */
    public static void iterative_refinement_stop_ratio(MemorySegment struct, double fieldValue) {
        struct.set(iterative_refinement_stop_ratio$LAYOUT, iterative_refinement_stop_ratio$OFFSET, fieldValue);
    }

    private static final OfBoolean presolve_enable$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("presolve_enable"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool presolve_enable
     * }
     */
    public static final OfBoolean presolve_enable$layout() {
        return presolve_enable$LAYOUT;
    }

    private static final long presolve_enable$OFFSET = $LAYOUT.byteOffset(groupElement("presolve_enable"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool presolve_enable
     * }
     */
    public static final long presolve_enable$offset() {
        return presolve_enable$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool presolve_enable
     * }
     */
    public static boolean presolve_enable(MemorySegment struct) {
        return struct.get(presolve_enable$LAYOUT, presolve_enable$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool presolve_enable
     * }
     */
    public static void presolve_enable(MemorySegment struct, boolean fieldValue) {
        struct.set(presolve_enable$LAYOUT, presolve_enable$OFFSET, fieldValue);
    }

    private static final SequenceLayout pardiso_iparm$LAYOUT = (SequenceLayout)$LAYOUT.select(groupElement("pardiso_iparm"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int32_t pardiso_iparm[64]
     * }
     */
    public static final SequenceLayout pardiso_iparm$layout() {
        return pardiso_iparm$LAYOUT;
    }

    private static final long pardiso_iparm$OFFSET = $LAYOUT.byteOffset(groupElement("pardiso_iparm"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int32_t pardiso_iparm[64]
     * }
     */
    public static final long pardiso_iparm$offset() {
        return pardiso_iparm$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int32_t pardiso_iparm[64]
     * }
     */
    public static MemorySegment pardiso_iparm(MemorySegment struct) {
        return struct.asSlice(pardiso_iparm$OFFSET, pardiso_iparm$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int32_t pardiso_iparm[64]
     * }
     */
    public static void pardiso_iparm(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, pardiso_iparm$OFFSET, pardiso_iparm$LAYOUT.byteSize());
    }

    private static long[] pardiso_iparm$DIMS = { 64 };

    /**
     * Dimensions for array field:
     * {@snippet lang=c :
     * int32_t pardiso_iparm[64]
     * }
     */
    public static long[] pardiso_iparm$dimensions() {
        return pardiso_iparm$DIMS;
    }
    private static final VarHandle pardiso_iparm$ELEM_HANDLE = pardiso_iparm$LAYOUT.varHandle(sequenceElement());

    /**
     * Indexed getter for field:
     * {@snippet lang=c :
     * int32_t pardiso_iparm[64]
     * }
     */
    public static int pardiso_iparm(MemorySegment struct, long index0) {
        return (int)pardiso_iparm$ELEM_HANDLE.get(struct, 0L, index0);
    }

    /**
     * Indexed setter for field:
     * {@snippet lang=c :
     * int32_t pardiso_iparm[64]
     * }
     */
    public static void pardiso_iparm(MemorySegment struct, long index0, int fieldValue) {
        pardiso_iparm$ELEM_HANDLE.set(struct, 0L, index0, fieldValue);
    }

    private static final OfBoolean pardiso_verbose$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("pardiso_verbose"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool pardiso_verbose
     * }
     */
    public static final OfBoolean pardiso_verbose$layout() {
        return pardiso_verbose$LAYOUT;
    }

    private static final long pardiso_verbose$OFFSET = $LAYOUT.byteOffset(groupElement("pardiso_verbose"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool pardiso_verbose
     * }
     */
    public static final long pardiso_verbose$offset() {
        return pardiso_verbose$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool pardiso_verbose
     * }
     */
    public static boolean pardiso_verbose(MemorySegment struct) {
        return struct.get(pardiso_verbose$LAYOUT, pardiso_verbose$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool pardiso_verbose
     * }
     */
    public static void pardiso_verbose(MemorySegment struct, boolean fieldValue) {
        struct.set(pardiso_verbose$LAYOUT, pardiso_verbose$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

