// Generated by jextract

package com.ustermetrics.clarabel4j.bindings;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct ClarabelDefaultSettings_f32 {
 *     uint32_t max_iter;
 *     double time_limit;
 *     bool verbose;
 *     float max_step_fraction;
 *     float tol_gap_abs;
 *     float tol_gap_rel;
 *     float tol_feas;
 *     float tol_infeas_abs;
 *     float tol_infeas_rel;
 *     float tol_ktratio;
 *     float reduced_tol_gap_abs;
 *     float reduced_tol_gap_rel;
 *     float reduced_tol_feas;
 *     float reduced_tol_infeas_abs;
 *     float reduced_tol_infeas_rel;
 *     float reduced_tol_ktratio;
 *     bool equilibrate_enable;
 *     uint32_t equilibrate_max_iter;
 *     float equilibrate_min_scaling;
 *     float equilibrate_max_scaling;
 *     float linesearch_backtrack_step;
 *     float min_switch_step_length;
 *     float min_terminate_step_length;
 *     bool direct_kkt_solver;
 *     enum ClarabelDirectSolveMethods direct_solve_method;
 *     bool static_regularization_enable;
 *     float static_regularization_constant;
 *     float static_regularization_proportional;
 *     bool dynamic_regularization_enable;
 *     float dynamic_regularization_eps;
 *     float dynamic_regularization_delta;
 *     bool iterative_refinement_enable;
 *     float iterative_refinement_reltol;
 *     float iterative_refinement_abstol;
 *     uint32_t iterative_refinement_max_iter;
 *     float iterative_refinement_stop_ratio;
 *     bool presolve_enable;
 * }
 * }
 */
public class ClarabelDefaultSettings_f32 {

    ClarabelDefaultSettings_f32() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        Clarabel_h.C_INT.withName("max_iter"),
        MemoryLayout.paddingLayout(4),
        Clarabel_h.C_DOUBLE.withName("time_limit"),
        Clarabel_h.C_BOOL.withName("verbose"),
        MemoryLayout.paddingLayout(3),
        Clarabel_h.C_FLOAT.withName("max_step_fraction"),
        Clarabel_h.C_FLOAT.withName("tol_gap_abs"),
        Clarabel_h.C_FLOAT.withName("tol_gap_rel"),
        Clarabel_h.C_FLOAT.withName("tol_feas"),
        Clarabel_h.C_FLOAT.withName("tol_infeas_abs"),
        Clarabel_h.C_FLOAT.withName("tol_infeas_rel"),
        Clarabel_h.C_FLOAT.withName("tol_ktratio"),
        Clarabel_h.C_FLOAT.withName("reduced_tol_gap_abs"),
        Clarabel_h.C_FLOAT.withName("reduced_tol_gap_rel"),
        Clarabel_h.C_FLOAT.withName("reduced_tol_feas"),
        Clarabel_h.C_FLOAT.withName("reduced_tol_infeas_abs"),
        Clarabel_h.C_FLOAT.withName("reduced_tol_infeas_rel"),
        Clarabel_h.C_FLOAT.withName("reduced_tol_ktratio"),
        Clarabel_h.C_BOOL.withName("equilibrate_enable"),
        MemoryLayout.paddingLayout(3),
        Clarabel_h.C_INT.withName("equilibrate_max_iter"),
        Clarabel_h.C_FLOAT.withName("equilibrate_min_scaling"),
        Clarabel_h.C_FLOAT.withName("equilibrate_max_scaling"),
        Clarabel_h.C_FLOAT.withName("linesearch_backtrack_step"),
        Clarabel_h.C_FLOAT.withName("min_switch_step_length"),
        Clarabel_h.C_FLOAT.withName("min_terminate_step_length"),
        Clarabel_h.C_BOOL.withName("direct_kkt_solver"),
        MemoryLayout.paddingLayout(3),
        Clarabel_h.C_INT.withName("direct_solve_method"),
        Clarabel_h.C_BOOL.withName("static_regularization_enable"),
        MemoryLayout.paddingLayout(3),
        Clarabel_h.C_FLOAT.withName("static_regularization_constant"),
        Clarabel_h.C_FLOAT.withName("static_regularization_proportional"),
        Clarabel_h.C_BOOL.withName("dynamic_regularization_enable"),
        MemoryLayout.paddingLayout(3),
        Clarabel_h.C_FLOAT.withName("dynamic_regularization_eps"),
        Clarabel_h.C_FLOAT.withName("dynamic_regularization_delta"),
        Clarabel_h.C_BOOL.withName("iterative_refinement_enable"),
        MemoryLayout.paddingLayout(3),
        Clarabel_h.C_FLOAT.withName("iterative_refinement_reltol"),
        Clarabel_h.C_FLOAT.withName("iterative_refinement_abstol"),
        Clarabel_h.C_INT.withName("iterative_refinement_max_iter"),
        Clarabel_h.C_FLOAT.withName("iterative_refinement_stop_ratio"),
        Clarabel_h.C_BOOL.withName("presolve_enable"),
        MemoryLayout.paddingLayout(7)
    ).withName("ClarabelDefaultSettings_f32");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt max_iter$LAYOUT = (OfInt)$LAYOUT.select(groupElement("max_iter"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t max_iter
     * }
     */
    public static final OfInt max_iter$layout() {
        return max_iter$LAYOUT;
    }

    private static final long max_iter$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t max_iter
     * }
     */
    public static final long max_iter$offset() {
        return max_iter$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t max_iter
     * }
     */
    public static int max_iter(MemorySegment struct) {
        return struct.get(max_iter$LAYOUT, max_iter$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t max_iter
     * }
     */
    public static void max_iter(MemorySegment struct, int fieldValue) {
        struct.set(max_iter$LAYOUT, max_iter$OFFSET, fieldValue);
    }

    private static final OfDouble time_limit$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("time_limit"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double time_limit
     * }
     */
    public static final OfDouble time_limit$layout() {
        return time_limit$LAYOUT;
    }

    private static final long time_limit$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double time_limit
     * }
     */
    public static final long time_limit$offset() {
        return time_limit$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double time_limit
     * }
     */
    public static double time_limit(MemorySegment struct) {
        return struct.get(time_limit$LAYOUT, time_limit$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double time_limit
     * }
     */
    public static void time_limit(MemorySegment struct, double fieldValue) {
        struct.set(time_limit$LAYOUT, time_limit$OFFSET, fieldValue);
    }

    private static final OfBoolean verbose$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("verbose"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool verbose
     * }
     */
    public static final OfBoolean verbose$layout() {
        return verbose$LAYOUT;
    }

    private static final long verbose$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool verbose
     * }
     */
    public static final long verbose$offset() {
        return verbose$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool verbose
     * }
     */
    public static boolean verbose(MemorySegment struct) {
        return struct.get(verbose$LAYOUT, verbose$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool verbose
     * }
     */
    public static void verbose(MemorySegment struct, boolean fieldValue) {
        struct.set(verbose$LAYOUT, verbose$OFFSET, fieldValue);
    }

    private static final OfFloat max_step_fraction$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("max_step_fraction"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float max_step_fraction
     * }
     */
    public static final OfFloat max_step_fraction$layout() {
        return max_step_fraction$LAYOUT;
    }

    private static final long max_step_fraction$OFFSET = 20;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float max_step_fraction
     * }
     */
    public static final long max_step_fraction$offset() {
        return max_step_fraction$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float max_step_fraction
     * }
     */
    public static float max_step_fraction(MemorySegment struct) {
        return struct.get(max_step_fraction$LAYOUT, max_step_fraction$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float max_step_fraction
     * }
     */
    public static void max_step_fraction(MemorySegment struct, float fieldValue) {
        struct.set(max_step_fraction$LAYOUT, max_step_fraction$OFFSET, fieldValue);
    }

    private static final OfFloat tol_gap_abs$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("tol_gap_abs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float tol_gap_abs
     * }
     */
    public static final OfFloat tol_gap_abs$layout() {
        return tol_gap_abs$LAYOUT;
    }

    private static final long tol_gap_abs$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float tol_gap_abs
     * }
     */
    public static final long tol_gap_abs$offset() {
        return tol_gap_abs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float tol_gap_abs
     * }
     */
    public static float tol_gap_abs(MemorySegment struct) {
        return struct.get(tol_gap_abs$LAYOUT, tol_gap_abs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float tol_gap_abs
     * }
     */
    public static void tol_gap_abs(MemorySegment struct, float fieldValue) {
        struct.set(tol_gap_abs$LAYOUT, tol_gap_abs$OFFSET, fieldValue);
    }

    private static final OfFloat tol_gap_rel$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("tol_gap_rel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float tol_gap_rel
     * }
     */
    public static final OfFloat tol_gap_rel$layout() {
        return tol_gap_rel$LAYOUT;
    }

    private static final long tol_gap_rel$OFFSET = 28;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float tol_gap_rel
     * }
     */
    public static final long tol_gap_rel$offset() {
        return tol_gap_rel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float tol_gap_rel
     * }
     */
    public static float tol_gap_rel(MemorySegment struct) {
        return struct.get(tol_gap_rel$LAYOUT, tol_gap_rel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float tol_gap_rel
     * }
     */
    public static void tol_gap_rel(MemorySegment struct, float fieldValue) {
        struct.set(tol_gap_rel$LAYOUT, tol_gap_rel$OFFSET, fieldValue);
    }

    private static final OfFloat tol_feas$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("tol_feas"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float tol_feas
     * }
     */
    public static final OfFloat tol_feas$layout() {
        return tol_feas$LAYOUT;
    }

    private static final long tol_feas$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float tol_feas
     * }
     */
    public static final long tol_feas$offset() {
        return tol_feas$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float tol_feas
     * }
     */
    public static float tol_feas(MemorySegment struct) {
        return struct.get(tol_feas$LAYOUT, tol_feas$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float tol_feas
     * }
     */
    public static void tol_feas(MemorySegment struct, float fieldValue) {
        struct.set(tol_feas$LAYOUT, tol_feas$OFFSET, fieldValue);
    }

    private static final OfFloat tol_infeas_abs$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("tol_infeas_abs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float tol_infeas_abs
     * }
     */
    public static final OfFloat tol_infeas_abs$layout() {
        return tol_infeas_abs$LAYOUT;
    }

    private static final long tol_infeas_abs$OFFSET = 36;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float tol_infeas_abs
     * }
     */
    public static final long tol_infeas_abs$offset() {
        return tol_infeas_abs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float tol_infeas_abs
     * }
     */
    public static float tol_infeas_abs(MemorySegment struct) {
        return struct.get(tol_infeas_abs$LAYOUT, tol_infeas_abs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float tol_infeas_abs
     * }
     */
    public static void tol_infeas_abs(MemorySegment struct, float fieldValue) {
        struct.set(tol_infeas_abs$LAYOUT, tol_infeas_abs$OFFSET, fieldValue);
    }

    private static final OfFloat tol_infeas_rel$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("tol_infeas_rel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float tol_infeas_rel
     * }
     */
    public static final OfFloat tol_infeas_rel$layout() {
        return tol_infeas_rel$LAYOUT;
    }

    private static final long tol_infeas_rel$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float tol_infeas_rel
     * }
     */
    public static final long tol_infeas_rel$offset() {
        return tol_infeas_rel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float tol_infeas_rel
     * }
     */
    public static float tol_infeas_rel(MemorySegment struct) {
        return struct.get(tol_infeas_rel$LAYOUT, tol_infeas_rel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float tol_infeas_rel
     * }
     */
    public static void tol_infeas_rel(MemorySegment struct, float fieldValue) {
        struct.set(tol_infeas_rel$LAYOUT, tol_infeas_rel$OFFSET, fieldValue);
    }

    private static final OfFloat tol_ktratio$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("tol_ktratio"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float tol_ktratio
     * }
     */
    public static final OfFloat tol_ktratio$layout() {
        return tol_ktratio$LAYOUT;
    }

    private static final long tol_ktratio$OFFSET = 44;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float tol_ktratio
     * }
     */
    public static final long tol_ktratio$offset() {
        return tol_ktratio$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float tol_ktratio
     * }
     */
    public static float tol_ktratio(MemorySegment struct) {
        return struct.get(tol_ktratio$LAYOUT, tol_ktratio$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float tol_ktratio
     * }
     */
    public static void tol_ktratio(MemorySegment struct, float fieldValue) {
        struct.set(tol_ktratio$LAYOUT, tol_ktratio$OFFSET, fieldValue);
    }

    private static final OfFloat reduced_tol_gap_abs$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("reduced_tol_gap_abs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float reduced_tol_gap_abs
     * }
     */
    public static final OfFloat reduced_tol_gap_abs$layout() {
        return reduced_tol_gap_abs$LAYOUT;
    }

    private static final long reduced_tol_gap_abs$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float reduced_tol_gap_abs
     * }
     */
    public static final long reduced_tol_gap_abs$offset() {
        return reduced_tol_gap_abs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float reduced_tol_gap_abs
     * }
     */
    public static float reduced_tol_gap_abs(MemorySegment struct) {
        return struct.get(reduced_tol_gap_abs$LAYOUT, reduced_tol_gap_abs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float reduced_tol_gap_abs
     * }
     */
    public static void reduced_tol_gap_abs(MemorySegment struct, float fieldValue) {
        struct.set(reduced_tol_gap_abs$LAYOUT, reduced_tol_gap_abs$OFFSET, fieldValue);
    }

    private static final OfFloat reduced_tol_gap_rel$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("reduced_tol_gap_rel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float reduced_tol_gap_rel
     * }
     */
    public static final OfFloat reduced_tol_gap_rel$layout() {
        return reduced_tol_gap_rel$LAYOUT;
    }

    private static final long reduced_tol_gap_rel$OFFSET = 52;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float reduced_tol_gap_rel
     * }
     */
    public static final long reduced_tol_gap_rel$offset() {
        return reduced_tol_gap_rel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float reduced_tol_gap_rel
     * }
     */
    public static float reduced_tol_gap_rel(MemorySegment struct) {
        return struct.get(reduced_tol_gap_rel$LAYOUT, reduced_tol_gap_rel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float reduced_tol_gap_rel
     * }
     */
    public static void reduced_tol_gap_rel(MemorySegment struct, float fieldValue) {
        struct.set(reduced_tol_gap_rel$LAYOUT, reduced_tol_gap_rel$OFFSET, fieldValue);
    }

    private static final OfFloat reduced_tol_feas$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("reduced_tol_feas"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float reduced_tol_feas
     * }
     */
    public static final OfFloat reduced_tol_feas$layout() {
        return reduced_tol_feas$LAYOUT;
    }

    private static final long reduced_tol_feas$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float reduced_tol_feas
     * }
     */
    public static final long reduced_tol_feas$offset() {
        return reduced_tol_feas$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float reduced_tol_feas
     * }
     */
    public static float reduced_tol_feas(MemorySegment struct) {
        return struct.get(reduced_tol_feas$LAYOUT, reduced_tol_feas$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float reduced_tol_feas
     * }
     */
    public static void reduced_tol_feas(MemorySegment struct, float fieldValue) {
        struct.set(reduced_tol_feas$LAYOUT, reduced_tol_feas$OFFSET, fieldValue);
    }

    private static final OfFloat reduced_tol_infeas_abs$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("reduced_tol_infeas_abs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float reduced_tol_infeas_abs
     * }
     */
    public static final OfFloat reduced_tol_infeas_abs$layout() {
        return reduced_tol_infeas_abs$LAYOUT;
    }

    private static final long reduced_tol_infeas_abs$OFFSET = 60;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float reduced_tol_infeas_abs
     * }
     */
    public static final long reduced_tol_infeas_abs$offset() {
        return reduced_tol_infeas_abs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float reduced_tol_infeas_abs
     * }
     */
    public static float reduced_tol_infeas_abs(MemorySegment struct) {
        return struct.get(reduced_tol_infeas_abs$LAYOUT, reduced_tol_infeas_abs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float reduced_tol_infeas_abs
     * }
     */
    public static void reduced_tol_infeas_abs(MemorySegment struct, float fieldValue) {
        struct.set(reduced_tol_infeas_abs$LAYOUT, reduced_tol_infeas_abs$OFFSET, fieldValue);
    }

    private static final OfFloat reduced_tol_infeas_rel$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("reduced_tol_infeas_rel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float reduced_tol_infeas_rel
     * }
     */
    public static final OfFloat reduced_tol_infeas_rel$layout() {
        return reduced_tol_infeas_rel$LAYOUT;
    }

    private static final long reduced_tol_infeas_rel$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float reduced_tol_infeas_rel
     * }
     */
    public static final long reduced_tol_infeas_rel$offset() {
        return reduced_tol_infeas_rel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float reduced_tol_infeas_rel
     * }
     */
    public static float reduced_tol_infeas_rel(MemorySegment struct) {
        return struct.get(reduced_tol_infeas_rel$LAYOUT, reduced_tol_infeas_rel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float reduced_tol_infeas_rel
     * }
     */
    public static void reduced_tol_infeas_rel(MemorySegment struct, float fieldValue) {
        struct.set(reduced_tol_infeas_rel$LAYOUT, reduced_tol_infeas_rel$OFFSET, fieldValue);
    }

    private static final OfFloat reduced_tol_ktratio$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("reduced_tol_ktratio"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float reduced_tol_ktratio
     * }
     */
    public static final OfFloat reduced_tol_ktratio$layout() {
        return reduced_tol_ktratio$LAYOUT;
    }

    private static final long reduced_tol_ktratio$OFFSET = 68;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float reduced_tol_ktratio
     * }
     */
    public static final long reduced_tol_ktratio$offset() {
        return reduced_tol_ktratio$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float reduced_tol_ktratio
     * }
     */
    public static float reduced_tol_ktratio(MemorySegment struct) {
        return struct.get(reduced_tol_ktratio$LAYOUT, reduced_tol_ktratio$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float reduced_tol_ktratio
     * }
     */
    public static void reduced_tol_ktratio(MemorySegment struct, float fieldValue) {
        struct.set(reduced_tol_ktratio$LAYOUT, reduced_tol_ktratio$OFFSET, fieldValue);
    }

    private static final OfBoolean equilibrate_enable$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("equilibrate_enable"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool equilibrate_enable
     * }
     */
    public static final OfBoolean equilibrate_enable$layout() {
        return equilibrate_enable$LAYOUT;
    }

    private static final long equilibrate_enable$OFFSET = 72;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool equilibrate_enable
     * }
     */
    public static final long equilibrate_enable$offset() {
        return equilibrate_enable$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool equilibrate_enable
     * }
     */
    public static boolean equilibrate_enable(MemorySegment struct) {
        return struct.get(equilibrate_enable$LAYOUT, equilibrate_enable$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool equilibrate_enable
     * }
     */
    public static void equilibrate_enable(MemorySegment struct, boolean fieldValue) {
        struct.set(equilibrate_enable$LAYOUT, equilibrate_enable$OFFSET, fieldValue);
    }

    private static final OfInt equilibrate_max_iter$LAYOUT = (OfInt)$LAYOUT.select(groupElement("equilibrate_max_iter"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t equilibrate_max_iter
     * }
     */
    public static final OfInt equilibrate_max_iter$layout() {
        return equilibrate_max_iter$LAYOUT;
    }

    private static final long equilibrate_max_iter$OFFSET = 76;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t equilibrate_max_iter
     * }
     */
    public static final long equilibrate_max_iter$offset() {
        return equilibrate_max_iter$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t equilibrate_max_iter
     * }
     */
    public static int equilibrate_max_iter(MemorySegment struct) {
        return struct.get(equilibrate_max_iter$LAYOUT, equilibrate_max_iter$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t equilibrate_max_iter
     * }
     */
    public static void equilibrate_max_iter(MemorySegment struct, int fieldValue) {
        struct.set(equilibrate_max_iter$LAYOUT, equilibrate_max_iter$OFFSET, fieldValue);
    }

    private static final OfFloat equilibrate_min_scaling$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("equilibrate_min_scaling"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float equilibrate_min_scaling
     * }
     */
    public static final OfFloat equilibrate_min_scaling$layout() {
        return equilibrate_min_scaling$LAYOUT;
    }

    private static final long equilibrate_min_scaling$OFFSET = 80;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float equilibrate_min_scaling
     * }
     */
    public static final long equilibrate_min_scaling$offset() {
        return equilibrate_min_scaling$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float equilibrate_min_scaling
     * }
     */
    public static float equilibrate_min_scaling(MemorySegment struct) {
        return struct.get(equilibrate_min_scaling$LAYOUT, equilibrate_min_scaling$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float equilibrate_min_scaling
     * }
     */
    public static void equilibrate_min_scaling(MemorySegment struct, float fieldValue) {
        struct.set(equilibrate_min_scaling$LAYOUT, equilibrate_min_scaling$OFFSET, fieldValue);
    }

    private static final OfFloat equilibrate_max_scaling$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("equilibrate_max_scaling"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float equilibrate_max_scaling
     * }
     */
    public static final OfFloat equilibrate_max_scaling$layout() {
        return equilibrate_max_scaling$LAYOUT;
    }

    private static final long equilibrate_max_scaling$OFFSET = 84;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float equilibrate_max_scaling
     * }
     */
    public static final long equilibrate_max_scaling$offset() {
        return equilibrate_max_scaling$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float equilibrate_max_scaling
     * }
     */
    public static float equilibrate_max_scaling(MemorySegment struct) {
        return struct.get(equilibrate_max_scaling$LAYOUT, equilibrate_max_scaling$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float equilibrate_max_scaling
     * }
     */
    public static void equilibrate_max_scaling(MemorySegment struct, float fieldValue) {
        struct.set(equilibrate_max_scaling$LAYOUT, equilibrate_max_scaling$OFFSET, fieldValue);
    }

    private static final OfFloat linesearch_backtrack_step$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("linesearch_backtrack_step"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float linesearch_backtrack_step
     * }
     */
    public static final OfFloat linesearch_backtrack_step$layout() {
        return linesearch_backtrack_step$LAYOUT;
    }

    private static final long linesearch_backtrack_step$OFFSET = 88;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float linesearch_backtrack_step
     * }
     */
    public static final long linesearch_backtrack_step$offset() {
        return linesearch_backtrack_step$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float linesearch_backtrack_step
     * }
     */
    public static float linesearch_backtrack_step(MemorySegment struct) {
        return struct.get(linesearch_backtrack_step$LAYOUT, linesearch_backtrack_step$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float linesearch_backtrack_step
     * }
     */
    public static void linesearch_backtrack_step(MemorySegment struct, float fieldValue) {
        struct.set(linesearch_backtrack_step$LAYOUT, linesearch_backtrack_step$OFFSET, fieldValue);
    }

    private static final OfFloat min_switch_step_length$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("min_switch_step_length"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float min_switch_step_length
     * }
     */
    public static final OfFloat min_switch_step_length$layout() {
        return min_switch_step_length$LAYOUT;
    }

    private static final long min_switch_step_length$OFFSET = 92;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float min_switch_step_length
     * }
     */
    public static final long min_switch_step_length$offset() {
        return min_switch_step_length$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float min_switch_step_length
     * }
     */
    public static float min_switch_step_length(MemorySegment struct) {
        return struct.get(min_switch_step_length$LAYOUT, min_switch_step_length$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float min_switch_step_length
     * }
     */
    public static void min_switch_step_length(MemorySegment struct, float fieldValue) {
        struct.set(min_switch_step_length$LAYOUT, min_switch_step_length$OFFSET, fieldValue);
    }

    private static final OfFloat min_terminate_step_length$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("min_terminate_step_length"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float min_terminate_step_length
     * }
     */
    public static final OfFloat min_terminate_step_length$layout() {
        return min_terminate_step_length$LAYOUT;
    }

    private static final long min_terminate_step_length$OFFSET = 96;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float min_terminate_step_length
     * }
     */
    public static final long min_terminate_step_length$offset() {
        return min_terminate_step_length$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float min_terminate_step_length
     * }
     */
    public static float min_terminate_step_length(MemorySegment struct) {
        return struct.get(min_terminate_step_length$LAYOUT, min_terminate_step_length$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float min_terminate_step_length
     * }
     */
    public static void min_terminate_step_length(MemorySegment struct, float fieldValue) {
        struct.set(min_terminate_step_length$LAYOUT, min_terminate_step_length$OFFSET, fieldValue);
    }

    private static final OfBoolean direct_kkt_solver$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("direct_kkt_solver"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool direct_kkt_solver
     * }
     */
    public static final OfBoolean direct_kkt_solver$layout() {
        return direct_kkt_solver$LAYOUT;
    }

    private static final long direct_kkt_solver$OFFSET = 100;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool direct_kkt_solver
     * }
     */
    public static final long direct_kkt_solver$offset() {
        return direct_kkt_solver$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool direct_kkt_solver
     * }
     */
    public static boolean direct_kkt_solver(MemorySegment struct) {
        return struct.get(direct_kkt_solver$LAYOUT, direct_kkt_solver$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool direct_kkt_solver
     * }
     */
    public static void direct_kkt_solver(MemorySegment struct, boolean fieldValue) {
        struct.set(direct_kkt_solver$LAYOUT, direct_kkt_solver$OFFSET, fieldValue);
    }

    private static final OfInt direct_solve_method$LAYOUT = (OfInt)$LAYOUT.select(groupElement("direct_solve_method"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * enum ClarabelDirectSolveMethods direct_solve_method
     * }
     */
    public static final OfInt direct_solve_method$layout() {
        return direct_solve_method$LAYOUT;
    }

    private static final long direct_solve_method$OFFSET = 104;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * enum ClarabelDirectSolveMethods direct_solve_method
     * }
     */
    public static final long direct_solve_method$offset() {
        return direct_solve_method$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * enum ClarabelDirectSolveMethods direct_solve_method
     * }
     */
    public static int direct_solve_method(MemorySegment struct) {
        return struct.get(direct_solve_method$LAYOUT, direct_solve_method$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * enum ClarabelDirectSolveMethods direct_solve_method
     * }
     */
    public static void direct_solve_method(MemorySegment struct, int fieldValue) {
        struct.set(direct_solve_method$LAYOUT, direct_solve_method$OFFSET, fieldValue);
    }

    private static final OfBoolean static_regularization_enable$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("static_regularization_enable"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool static_regularization_enable
     * }
     */
    public static final OfBoolean static_regularization_enable$layout() {
        return static_regularization_enable$LAYOUT;
    }

    private static final long static_regularization_enable$OFFSET = 108;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool static_regularization_enable
     * }
     */
    public static final long static_regularization_enable$offset() {
        return static_regularization_enable$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool static_regularization_enable
     * }
     */
    public static boolean static_regularization_enable(MemorySegment struct) {
        return struct.get(static_regularization_enable$LAYOUT, static_regularization_enable$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool static_regularization_enable
     * }
     */
    public static void static_regularization_enable(MemorySegment struct, boolean fieldValue) {
        struct.set(static_regularization_enable$LAYOUT, static_regularization_enable$OFFSET, fieldValue);
    }

    private static final OfFloat static_regularization_constant$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("static_regularization_constant"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float static_regularization_constant
     * }
     */
    public static final OfFloat static_regularization_constant$layout() {
        return static_regularization_constant$LAYOUT;
    }

    private static final long static_regularization_constant$OFFSET = 112;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float static_regularization_constant
     * }
     */
    public static final long static_regularization_constant$offset() {
        return static_regularization_constant$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float static_regularization_constant
     * }
     */
    public static float static_regularization_constant(MemorySegment struct) {
        return struct.get(static_regularization_constant$LAYOUT, static_regularization_constant$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float static_regularization_constant
     * }
     */
    public static void static_regularization_constant(MemorySegment struct, float fieldValue) {
        struct.set(static_regularization_constant$LAYOUT, static_regularization_constant$OFFSET, fieldValue);
    }

    private static final OfFloat static_regularization_proportional$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("static_regularization_proportional"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float static_regularization_proportional
     * }
     */
    public static final OfFloat static_regularization_proportional$layout() {
        return static_regularization_proportional$LAYOUT;
    }

    private static final long static_regularization_proportional$OFFSET = 116;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float static_regularization_proportional
     * }
     */
    public static final long static_regularization_proportional$offset() {
        return static_regularization_proportional$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float static_regularization_proportional
     * }
     */
    public static float static_regularization_proportional(MemorySegment struct) {
        return struct.get(static_regularization_proportional$LAYOUT, static_regularization_proportional$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float static_regularization_proportional
     * }
     */
    public static void static_regularization_proportional(MemorySegment struct, float fieldValue) {
        struct.set(static_regularization_proportional$LAYOUT, static_regularization_proportional$OFFSET, fieldValue);
    }

    private static final OfBoolean dynamic_regularization_enable$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("dynamic_regularization_enable"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool dynamic_regularization_enable
     * }
     */
    public static final OfBoolean dynamic_regularization_enable$layout() {
        return dynamic_regularization_enable$LAYOUT;
    }

    private static final long dynamic_regularization_enable$OFFSET = 120;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool dynamic_regularization_enable
     * }
     */
    public static final long dynamic_regularization_enable$offset() {
        return dynamic_regularization_enable$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool dynamic_regularization_enable
     * }
     */
    public static boolean dynamic_regularization_enable(MemorySegment struct) {
        return struct.get(dynamic_regularization_enable$LAYOUT, dynamic_regularization_enable$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool dynamic_regularization_enable
     * }
     */
    public static void dynamic_regularization_enable(MemorySegment struct, boolean fieldValue) {
        struct.set(dynamic_regularization_enable$LAYOUT, dynamic_regularization_enable$OFFSET, fieldValue);
    }

    private static final OfFloat dynamic_regularization_eps$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("dynamic_regularization_eps"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float dynamic_regularization_eps
     * }
     */
    public static final OfFloat dynamic_regularization_eps$layout() {
        return dynamic_regularization_eps$LAYOUT;
    }

    private static final long dynamic_regularization_eps$OFFSET = 124;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float dynamic_regularization_eps
     * }
     */
    public static final long dynamic_regularization_eps$offset() {
        return dynamic_regularization_eps$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float dynamic_regularization_eps
     * }
     */
    public static float dynamic_regularization_eps(MemorySegment struct) {
        return struct.get(dynamic_regularization_eps$LAYOUT, dynamic_regularization_eps$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float dynamic_regularization_eps
     * }
     */
    public static void dynamic_regularization_eps(MemorySegment struct, float fieldValue) {
        struct.set(dynamic_regularization_eps$LAYOUT, dynamic_regularization_eps$OFFSET, fieldValue);
    }

    private static final OfFloat dynamic_regularization_delta$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("dynamic_regularization_delta"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float dynamic_regularization_delta
     * }
     */
    public static final OfFloat dynamic_regularization_delta$layout() {
        return dynamic_regularization_delta$LAYOUT;
    }

    private static final long dynamic_regularization_delta$OFFSET = 128;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float dynamic_regularization_delta
     * }
     */
    public static final long dynamic_regularization_delta$offset() {
        return dynamic_regularization_delta$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float dynamic_regularization_delta
     * }
     */
    public static float dynamic_regularization_delta(MemorySegment struct) {
        return struct.get(dynamic_regularization_delta$LAYOUT, dynamic_regularization_delta$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float dynamic_regularization_delta
     * }
     */
    public static void dynamic_regularization_delta(MemorySegment struct, float fieldValue) {
        struct.set(dynamic_regularization_delta$LAYOUT, dynamic_regularization_delta$OFFSET, fieldValue);
    }

    private static final OfBoolean iterative_refinement_enable$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("iterative_refinement_enable"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool iterative_refinement_enable
     * }
     */
    public static final OfBoolean iterative_refinement_enable$layout() {
        return iterative_refinement_enable$LAYOUT;
    }

    private static final long iterative_refinement_enable$OFFSET = 132;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool iterative_refinement_enable
     * }
     */
    public static final long iterative_refinement_enable$offset() {
        return iterative_refinement_enable$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool iterative_refinement_enable
     * }
     */
    public static boolean iterative_refinement_enable(MemorySegment struct) {
        return struct.get(iterative_refinement_enable$LAYOUT, iterative_refinement_enable$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool iterative_refinement_enable
     * }
     */
    public static void iterative_refinement_enable(MemorySegment struct, boolean fieldValue) {
        struct.set(iterative_refinement_enable$LAYOUT, iterative_refinement_enable$OFFSET, fieldValue);
    }

    private static final OfFloat iterative_refinement_reltol$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("iterative_refinement_reltol"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float iterative_refinement_reltol
     * }
     */
    public static final OfFloat iterative_refinement_reltol$layout() {
        return iterative_refinement_reltol$LAYOUT;
    }

    private static final long iterative_refinement_reltol$OFFSET = 136;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float iterative_refinement_reltol
     * }
     */
    public static final long iterative_refinement_reltol$offset() {
        return iterative_refinement_reltol$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float iterative_refinement_reltol
     * }
     */
    public static float iterative_refinement_reltol(MemorySegment struct) {
        return struct.get(iterative_refinement_reltol$LAYOUT, iterative_refinement_reltol$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float iterative_refinement_reltol
     * }
     */
    public static void iterative_refinement_reltol(MemorySegment struct, float fieldValue) {
        struct.set(iterative_refinement_reltol$LAYOUT, iterative_refinement_reltol$OFFSET, fieldValue);
    }

    private static final OfFloat iterative_refinement_abstol$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("iterative_refinement_abstol"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float iterative_refinement_abstol
     * }
     */
    public static final OfFloat iterative_refinement_abstol$layout() {
        return iterative_refinement_abstol$LAYOUT;
    }

    private static final long iterative_refinement_abstol$OFFSET = 140;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float iterative_refinement_abstol
     * }
     */
    public static final long iterative_refinement_abstol$offset() {
        return iterative_refinement_abstol$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float iterative_refinement_abstol
     * }
     */
    public static float iterative_refinement_abstol(MemorySegment struct) {
        return struct.get(iterative_refinement_abstol$LAYOUT, iterative_refinement_abstol$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float iterative_refinement_abstol
     * }
     */
    public static void iterative_refinement_abstol(MemorySegment struct, float fieldValue) {
        struct.set(iterative_refinement_abstol$LAYOUT, iterative_refinement_abstol$OFFSET, fieldValue);
    }

    private static final OfInt iterative_refinement_max_iter$LAYOUT = (OfInt)$LAYOUT.select(groupElement("iterative_refinement_max_iter"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t iterative_refinement_max_iter
     * }
     */
    public static final OfInt iterative_refinement_max_iter$layout() {
        return iterative_refinement_max_iter$LAYOUT;
    }

    private static final long iterative_refinement_max_iter$OFFSET = 144;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t iterative_refinement_max_iter
     * }
     */
    public static final long iterative_refinement_max_iter$offset() {
        return iterative_refinement_max_iter$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t iterative_refinement_max_iter
     * }
     */
    public static int iterative_refinement_max_iter(MemorySegment struct) {
        return struct.get(iterative_refinement_max_iter$LAYOUT, iterative_refinement_max_iter$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t iterative_refinement_max_iter
     * }
     */
    public static void iterative_refinement_max_iter(MemorySegment struct, int fieldValue) {
        struct.set(iterative_refinement_max_iter$LAYOUT, iterative_refinement_max_iter$OFFSET, fieldValue);
    }

    private static final OfFloat iterative_refinement_stop_ratio$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("iterative_refinement_stop_ratio"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float iterative_refinement_stop_ratio
     * }
     */
    public static final OfFloat iterative_refinement_stop_ratio$layout() {
        return iterative_refinement_stop_ratio$LAYOUT;
    }

    private static final long iterative_refinement_stop_ratio$OFFSET = 148;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float iterative_refinement_stop_ratio
     * }
     */
    public static final long iterative_refinement_stop_ratio$offset() {
        return iterative_refinement_stop_ratio$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float iterative_refinement_stop_ratio
     * }
     */
    public static float iterative_refinement_stop_ratio(MemorySegment struct) {
        return struct.get(iterative_refinement_stop_ratio$LAYOUT, iterative_refinement_stop_ratio$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float iterative_refinement_stop_ratio
     * }
     */
    public static void iterative_refinement_stop_ratio(MemorySegment struct, float fieldValue) {
        struct.set(iterative_refinement_stop_ratio$LAYOUT, iterative_refinement_stop_ratio$OFFSET, fieldValue);
    }

    private static final OfBoolean presolve_enable$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("presolve_enable"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool presolve_enable
     * }
     */
    public static final OfBoolean presolve_enable$layout() {
        return presolve_enable$LAYOUT;
    }

    private static final long presolve_enable$OFFSET = 152;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool presolve_enable
     * }
     */
    public static final long presolve_enable$offset() {
        return presolve_enable$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool presolve_enable
     * }
     */
    public static boolean presolve_enable(MemorySegment struct) {
        return struct.get(presolve_enable$LAYOUT, presolve_enable$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool presolve_enable
     * }
     */
    public static void presolve_enable(MemorySegment struct, boolean fieldValue) {
        struct.set(presolve_enable$LAYOUT, presolve_enable$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

